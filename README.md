# ğŸ“˜ Take-Home Assignment: Campaign Monitor
### *Elixir / Phoenix / LiveView*

Thank you for your interest!
This assignment is designed to help us understand how you think about Elixir, Phoenix, LiveView, and system design.
Completion time is typically **3â€“6 hours**, though some candidates spend additional time on polish. There is no strict limit.

âš ï¸ **Using AI tools is not only allowed â€” it is *crucial* for keeping the assignment within the time box.**
We want to see how you *orchestrate* AI support, not how much boilerplate you can write manually.

---

## ğŸ¯ Goal

Build a small Phoenix + LiveView application that lets a user:

1. **Create, update, and delete media campaigns**
2. **Simulate real-time "traffic events"** (impressions + clicks)
3. **Display a live-updating dashboard** with campaign metrics

You **do not** need to integrate with external DSP APIs.
All traffic can be simulated locally using `Process.send_after/3`, `GenServer`, or any other mechanism you prefer.

---

## ğŸ§± Requirements

### 1. Campaign CRUD

A campaign has the following fields:

- `name` â€” string
- `daily_budget` â€” integer or decimal
- `status` â€” `"active"` or `"paused"`

You should support:

- Create
- Edit
- Delete
- List all campaigns

This can be a single LiveView or multiple â€” up to you.

---

### 2. Campaign Detail Page (LiveView)

When viewing a campaign, show:

- **Live updating list or table** of events (impressions + clicks)
- Display computed metrics such as:
  - Total impressions
  - Total clicks
  - **CTR** (click-through rate)

You choose the UI layout â€” simple is fine.

---

### 3. "Simulate Traffic" Functionality

Each campaign detail page should include a way to start or trigger traffic simulation:

- Example: a button to start generating events
- Events can be generated by:
  - a `GenServer`,
  - a `Task`,
  - or scheduled messages to the LiveView itself.

The core idea:
**Show us how you think about state, messages, concurrency, and LiveView update flows.**

---

### 4. Resilience Considerations

Consider what happens if the traffic simulator crashes or encounters an error mid-stream. You don't need to implement a full supervision tree, but think about how you'd handle this gracefully â€” and mention your approach in `DECISIONS.md`.

---

## Optional (but welcomed)

These are **not required**, but feel free to include them if time permits:

- **Tests** â€” If you include tests, focus on the areas you consider most critical (e.g., business logic, LiveView interactions, GenServer behavior). We're interested in *what* you choose to test and *why*.
- Charting the metrics using LiveView components
- Persisting events to the database
- Tailwind styling
- PubSub-based updates across sessions
- Supervising traffic generators under an application supervision tree

---

## ğŸ“ Deliverables

1. **A working Phoenix application** (LiveView required)
2. A short **`DECISIONS.md`** file containing:
   - Why you structured it the way you did
   - Any trade-offs you made
   - How you handled (or would handle) error cases
   - Anything you would do with more time
   - How you used AI to help you
3. Share the repository link with us.

We do **not** review every line of code.
We care about understanding how you **think** and how you **explain** your choices.

---

## ğŸš€ Running the Project

Include minimal instructions in your repo on how to run it:

```bash
mix deps.get
mix ecto.setup
mix phx.server
```

Add any extra steps if needed (e.g., environment variables, Node.js dependencies).

---

## ğŸ“© Submission

Fork or clone this repository, complete the assignment, push it to your own GitHub, and send the link to `alex.extern@alchemist.ml`.

The last step of the interview process is an **on-site conversation at our office**, where we discuss your solution and how you
approached it.

---

If anything is unclear, feel free to make reasonable assumptions and document them.

Good luck â€” and have fun building it! ğŸš€